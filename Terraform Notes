Commands to Manage Workspaces
ğŸ”¹ 1. Create a New Workspace
terraform workspace new <workspace_name>


Example:

terraform workspace new dev

ğŸ”¹ 2. List All Workspaces
terraform workspace list


ğŸ”¹ The current workspace is marked with an asterisk (*).

ğŸ”¹ 3. Switch to an Existing Workspace
terraform workspace select <workspace_name>


Example:

terraform workspace select dev

ğŸ”¹ 4. Show Current Workspace
terraform workspace show

ğŸ”¹ 5. Delete a Workspace

(Only possible if the workspace is not currently selected)

terraform workspace delete <workspace_name>

âš ï¸ Notes

The default workspace is always present.

Workspaces isolate state files, not resources themselves unless your configuration (e.g., backend or resource names) accounts for the workspace name.

Best practice: Use terraform.workspace in resource naming or backend configuration to fully isolate resources across workspaces.


** 
Great! Hereâ€™s a full example of how to use terraform.workspace in your Terraform configuration to manage isolated environments like dev, stage, and prod using workspaces.

âœ… Goal

We'll create an S3 bucket with a name that changes based on the current workspace, so each workspace creates its own isolated resource.

ğŸ“ Example: main.tf
provider "aws" {
  region = "us-east-1"
}

resource "aws_s3_bucket" "example" {
  bucket = "my-app-bucket-${terraform.workspace}"
  acl    = "private"

  tags = {
    Environment = terraform.workspace
  }
}

output "bucket_name" {
  value = aws_s3_bucket.example.bucket
}


Steps to Use It
1. Initialize Terraform
terraform init

2. Create and Switch to a Workspace
terraform workspace new dev


(or switch to an existing one)

terraform workspace select dev

3. Apply the Configuration
terraform apply


ğŸ”¸ This will create an S3 bucket named my-app-bucket-dev.

4. Switch to Another Workspace
terraform workspace new prod
terraform apply

This creates a separate bucket like my-app-bucket-prod.

Each workspace maintains its own state, so the dev and prod buckets won't conflict or overwrite each other.

Important Notes

You must ensure that resource names (like S3 buckets) are unique across workspaces, especially for global resources (S3 bucket names must be globally unique in AWS).

Use terraform.workspace in tags, names, or logic to customize resources per environment.




***
Great â€” letâ€™s extend the setup to include workspace-specific variables and show how to configure different backends per workspace if needed.

ğŸ¯ Goal

We'll:

Use different values (e.g. tags or instance types) depending on the workspace.

Optionally configure workspace-aware backends (e.g. different S3 state files per workspace).

1ï¸âƒ£ Workspace-Specific Variables Using locals

You can use a locals block to change values based on the current workspace.

ğŸ”¸ Example with EC2 instance type:
locals {
  instance_type_map = {
    dev     = "t2.micro"
    staging = "t3.micro"
    prod    = "t3.large"
  }

  instance_type = lookup(local.instance_type_map, terraform.workspace, "t2.micro")
}

resource "aws_instance" "example" {
  ami           = "ami-0c55b159cbfafe1f0" # Use your region's latest Amazon Linux 2 AMI
  instance_type = local.instance_type

  tags = {
    Environment = terraform.workspace
  }
}


So:

dev â†’ t2.micro

prod â†’ t3.large

Defaults to t2.micro if workspace not listed.

2ï¸âƒ£ Different Terraform State Backends per Workspace (Optional Advanced)
âš ï¸ Caution

Terraform does not support dynamic backends (i.e. using terraform.workspace directly in backend blocks). But you can manually separate state per workspace by using key patterns in the backend configuration.

ğŸ”¸ Example: backend.tf
terraform {
  backend "s3" {
    bucket = "my-terraform-state-bucket"
    key    = "env/${terraform.workspace}/terraform.tfstate"
    region = "us-east-1"
  }
}

ğŸš¨ But this wonâ€™t work directly!

Because the backend block is evaluated before any variables or functions like terraform.workspace.

âœ… Workaround: Use CLI Workspaces + Pre-Set Backend Files

You can:

Create separate backend-<workspace>.tf files for each workspace.

Use them like:

terraform init -backend-config=backend-dev.tf
terraform workspace select dev

ğŸ“ backend-dev.tf
bucket = "my-terraform-state-bucket"
key    = "env/dev/terraform.tfstate"
region = "us-east-1"


Repeat for backend-prod.tf, backend-staging.tf, etc.

âœ… Summary
Feature	Terraform Support	Notes
terraform.workspace	âœ… Yes	Use in resource names, tags, locals
Dynamic backends	âŒ No	Workaround with separate backend config files per workspace
Workspace-specific variables	âœ… Yes	Use locals + maps + lookup()



** IMPORT FROM AWS CONSOLE **

Absolutely. Letâ€™s walk through a complete example: how to import a manually created AWS resource into Terraform step by step, with a real Terraform .tf file example.

âœ… Scenario Example: Import a Manually Created AWS EC2 Instance

Letâ€™s say:

You manually launched an EC2 instance via the AWS Console

Its instance ID is i-0123456789abcdef0

You now want to bring it under Terraform control

ğŸ”§ Step-by-Step: Importing AWS Resource into Terraform
ğŸŸ¢ Step 1: Create a Terraform Resource Block

First, create a minimal Terraform resource block for the EC2 instance in your Terraform configuration.

ğŸ“„ main.tf

provider "aws" {
  region = "us-east-1"
}

resource "aws_instance" "imported_ec2" {
  # No arguments yet; Terraform will not use this to change anything yet.
  # We'll fill in the actual attributes after importing.
}

ğŸŸ¢ Step 2: Initialize Terraform (if not already done)
terraform init

ğŸŸ¢ Step 3: Import the EC2 Instance into Terraform State

Use the EC2 instance's ID from the AWS Console.

terraform import aws_instance.imported_ec2 i-0123456789abcdef0


âœ… This adds the EC2 instance to your .tfstate file, so Terraform knows it exists.

ğŸŸ¢ Step 4: Review the Imported Resource

Run:

terraform state show aws_instance.imported_ec2


Youâ€™ll get output like this:

# aws_instance.imported_ec2:
resource "aws_instance" "imported_ec2" {
  ami                          = "ami-0c55b159cbfafe1f0"
  instance_type                = "t2.micro"
  subnet_id                    = "subnet-abc123"
  vpc_security_group_ids       = ["sg-0abc123"]
  associate_public_ip_address  = true
  key_name                     = "my-keypair"
  tags = {
    Name = "ManuallyCreatedEC2"
  }
}

ğŸŸ¢ Step 5: Update the .tf File with Actual Attributes

Now, modify your main.tf resource to match the real configuration of the instance:

resource "aws_instance" "imported_ec2" {
  ami                    = "ami-0c55b159cbfafe1f0"
  instance_type          = "t2.micro"
  subnet_id              = "subnet-abc123"
  vpc_security_group_ids = ["sg-0abc123"]
  associate_public_ip_address = true
  key_name               = "my-keypair"

  tags = {
    Name = "ManuallyCreatedEC2"
  }
}

ğŸŸ¢ Step 6: Run terraform plan to Confirm No Drift
terraform plan


If your .tf file matches the state and real AWS resource, the plan will show:

No changes. Your infrastructure matches the configuration.

âœ… Success â€” the resource is now under Terraform management!

âœ… Summary Table
Step	Command / Action	Purpose
1	Create resource block in .tf	Define structure for imported resource
2	terraform init	Initialize Terraform
3	terraform import <resource> <id>	Import AWS resource into state
4	terraform state show <resource>	View imported attributes
5	Update .tf file	Match actual resource configuration
6	terraform plan	Confirm sync between code and AWS
ğŸ” Bonus: Import Other AWS Resources
AWS Resource	Terraform Type	Example Command
S3 Bucket	aws_s3_bucket	terraform import aws_s3_bucket.mybucket my-console-bucket
IAM Role	aws_iam_role	terraform import aws_iam_role.myrole my-iam-role-name
Security Group	aws_security_group	terraform import aws_security_group.sg sg-0123abcd


** Import from one module to another module ** 
how to import or pass one module into another module in terraform
In Terraform, modules are isolated and don't automatically share resources or outputs. However, you can pass values from one module to another using output variables and input variables â€” effectively "connecting" modules through the root module (your main config).

âœ… Goal

You cannot directly "import" one module into another, but you can pass data between them like this:

module A (produces output) â†’ root module â†’ module B (receives input)
ğŸ“Œ Step-by-Step: Pass One Module's Output to Another Module
ğŸ”¹ 1. Module A: Define an Output

Let's say Module A creates a VPC and outputs the VPC ID.

# modules/vpc/main.tf
resource "aws_vpc" "main" {
  cidr_block = "10.0.0.0/16"
}

output "vpc_id" {
  value = aws_vpc.main.id
}

ğŸ”¹ 2. Root Module: Call Module A and Capture the Output
# main.tf
module "vpc" {
  source = "./modules/vpc"
}


Now module.vpc.vpc_id is available in the root module.

ğŸ”¹ 3. Module B: Accept the Input as a Variable

Let's say Module B creates a subnet inside the VPC.

# modules/subnet/variables.tf
variable "vpc_id" {
  type = string
}

# modules/subnet/main.tf
resource "aws_subnet" "main" {
  vpc_id     = var.vpc_id
  cidr_block = "10.0.1.0/24"
}

ğŸ”¹ 4. Root Module: Pass Output from Module A to Module B
# main.tf
module "subnet" {
  source = "./modules/subnet"
  vpc_id = module.vpc.vpc_id
}

âœ… Result

Youâ€™ve now passed a value from Module A to Module B using the root module as a bridge.

ğŸ§  Terraform Does Not Support:

âŒ Importing one module directly into another

âŒ Calling one module inside another module like a nested function

Terraform modules are intended to be self-contained and composable, and the root module acts as the orchestrator.

âœ… Visual Summary
[ Module A ] ---> outputs ---> [ Root Module ] ---> inputs ---> [ Module B ]

ğŸ” Real-World Use Case Example

Module A: Creates VPC

Module B: Creates subnets using VPC ID from Module A

Module C: Creates EC2 instances in subnets from Module B

Everything is wired through the root module, using:

output in the source module

input variable in the destination module

module.<name>.<output> in root module


** what is the difference between terraform import and terraform taint ?
The terraform import and terraform taint commands in Terraform are used for very different purposes. Here's a clear comparison to help you understand the difference:

terraform import :

Purpose:
To bring existing infrastructure under Terraform management.

Use Case:
You have an existing resource (e.g., an AWS EC2 instance, an S3 bucket) that was created outside of Terraform, and you want Terraform to manage it.

What it does:

Associates a real-world resource with a resource in your Terraform configuration.

Updates the Terraform state file with information about the existing resource.

Does NOT create or modify the infrastructure.

You still need to write the matching Terraform configuration manually.

Example:

terraform import aws_instance.my_instance i-0abcd1234efgh5678


This tells Terraform: â€œThe EC2 instance with ID i-0abcd1234efgh5678 should now be managed as aws_instance.my_instance.â€

ğŸ”§ terraform taint

Purpose:
To mark a resource for destruction and recreation on the next terraform apply.

Use Case:
A resource is in a bad state, or you want to force it to be re-created, even if its configuration hasnâ€™t changed.

What it does:

Marks the specified resource as tainted in the state file.

On the next terraform apply, Terraform will destroy and re-create the resource.

Example:

terraform taint aws_instance.my_instance


This tells Terraform: â€œRecreate this instance the next time I run terraform apply, even if nothing about it has changed.â€

ğŸ” Summary Comparison
Feature	terraform import	terraform taint
Main Purpose	Bring existing resource into Terraform	Force recreation of a resource
Affects Infrastructure?	No (just updates the state file)	Yes (destroys and recreates resource)
Needs Config Block?	Yes, must already exist in the code	Yes, resource must be in configuration
Common Use Case	Adopting existing infra into Terraform management	Replacing a broken/misbehaving resource


**
how do you manage secrets in terraform without hardcoding them ?
Great question! Managing secrets securely in Terraform is critical to protecting your infrastructure. Hardcoding secrets in Terraform files (like .tf or .tfvars) is strongly discouraged.

Here are the best and most secure ways to manage secrets in Terraform without hardcoding them:

âœ… 1. Use Environment Variables

Set sensitive values like API keys or cloud provider credentials as environment variables.

In Terraform:
You can reference environment variables using the TF_VAR_ prefix.

Example:

export TF_VAR_db_password="super-secret-password"


In your Terraform code:

variable "db_password" {
  type      = string
  sensitive = true
}

resource "aws_db_instance" "example" {
  ...
  password = var.db_password
}


Marking it as sensitive = true hides it from plan/apply output.

âœ… 2. Use a .tfvars File (With .gitignore!)

You can store secrets in a separate .tfvars file and never commit it to version control.

Example: secrets.auto.tfvars

db_password = "super-secret-password"


Protect it:
Add this to .gitignore:

*.tfvars

âœ… 3. Use a Secret Management Tool

This is the most secure and scalable option, especially in production environments.

ğŸ” Options include:
Tool	Description
HashiCorp Vault	First-class integration with Terraform. Use the Vault provider
 or fetch secrets at runtime.
AWS Secrets Manager	Store secrets in AWS and fetch them using the AWS provider or data sources.
Azure Key Vault	Fetch secrets via Terraform's azurerm_key_vault_secret data source.
Google Secret Manager	Similar integration with GCP secrets.

Example with AWS Secrets Manager:

data "aws_secretsmanager_secret_version" "db_password" {
  secret_id = "my_db_password"
}

resource "aws_db_instance" "example" {
  password = data.aws_secretsmanager_secret_version.db_password.secret_string
}

âœ… 4. Use Terraform Cloud or Terraform Enterprise Variables

If you're using Terraform Cloud or Enterprise, you can store sensitive variables securely in the workspace settings.

Mark them as sensitive, and they will be encrypted and hidden in logs.

âœ… 5. Use sensitive = true in Terraform Code

Even if you securely load secrets, always mark them as sensitive in your variable blocks:

variable "api_key" {
  type      = string
  sensitive = true
}


This prevents the value from being shown in terraform plan or terraform apply output.

âŒ Avoid These Bad Practices:

âŒ Hardcoding secrets directly in .tf files

âŒ Committing secrets to version control

âŒ Leaving unencrypted .tfvars in shared storage

ğŸ§ª Bonus Tip: Combine with CI/CD Secrets Management

Use your CI/CD pipeline's secrets store (e.g., GitHub Actions Secrets, GitLab CI, CircleCI, etc.) to inject environment variables or terraform.tfvars securely at runtime.


** Count vs for_each **

âœ… Terraform count vs for_each
ğŸ”¢ count

Creates multiple identical resources.

Accepts a number.

Access each resource using count.index.

Simple and good for repeating the same resource.

ğŸ” for_each

Creates resources from a set or map.

Use each.key and each.value to access elements.

Supports customization of each resource.

More flexible and stable if your inputs change.

ğŸ— Real-World Scenario:

You want to create EC2 instances for dev, test, and prod environments.

With count, we'll just repeat the same instance N times.

With for_each, weâ€™ll assign different instance types for each environment.

ğŸ“˜ Example 1: Using count
â• Goal:

Create 3 identical EC2 instances named dev, test, and prod.

ğŸ“„ Terraform Code (Using count)
provider "aws" {
  region = "us-east-1"
}

variable "envs" {
  default = ["dev", "test", "prod"]
}

resource "aws_instance" "example" {
  count         = length(var.envs)
  ami           = "ami-0c55b159cbfafe1f0"  # Amazon Linux 2
  instance_type = "t2.micro"

  tags = {
    Name = var.envs[count.index]
  }
}

ğŸ§¾ Explanation:

count = 3 creates three EC2 instances.

We use count.index to access each environment name (dev, test, prod).

All instances are of type t2.micro.

ğŸ–¨ Output Example:
output "instance_ids" {
  value = aws_instance.example[*].id
}

Output:
instance_ids = [
  "i-01abc123dev",
  "i-02def456test",
  "i-03ghi789prod"
]

âš ï¸ Limitation:

If you remove "test" from the list, "prod"'s index changes, and Terraform destroys and recreates the "prod" instance. Not ideal.

ğŸ“˜ Example 2: Using for_each
â• Goal:

Create EC2 instances for each environment with a custom instance type.

ğŸ“„ Terraform Code (Using for_each)
provider "aws" {
  region = "us-east-1"
}

variable "instances" {
  default = {
    dev  = "t2.micro"
    test = "t3.micro"
    prod = "t3.medium"
  }
}

resource "aws_instance" "example" {
  for_each      = var.instances
  ami           = "ami-0c55b159cbfafe1f0"
  instance_type = each.value

  tags = {
    Name = each.key
    Env  = each.key
  }
}

ğŸ§¾ Explanation:

for_each iterates over a map.

each.key is the environment (dev, test, prod).

each.value is the instance type (t2.micro, etc.).

Each EC2 instance is customized per environment.

ğŸ–¨ Output Example:
output "instance_ids" {
  value = {
    for env, instance in aws_instance.example :
    env => instance.id
  }
}

Output:
instance_ids = {
  "dev"  = "i-01abc123"
  "test" = "i-02def456"
  "prod" = "i-03ghi789"
}

âœ… Advantages:

Easy to customize each resource.

If you remove "test", only that instance is destroyed.

"prod" remains unaffected â€” no resource shifting.

ğŸ§¾ Summary Table
Feature	count	for_each
Input type	Number	Set or Map
Access	count.index	each.key, each.value
Custom resource config	âŒ Harder	âœ… Easy
Resource stability	âŒ Can shift on list change	âœ… Stable due to key-based mapping
Best for	Identical resources	Unique/named resources
âœ… When to Use What?
Use Case	Use
3 EC2s with the same config	count
EC2s with different instance types	for_each
Want resource stability on changes	for_each
Want simpler iteration	count


** how do you handle drift detection in terraform ? **
Great question â€” drift detection is an essential part of managing infrastructure with Terraform.

ğŸ” What is Drift?

Drift happens when the real-world infrastructure (e.g., in AWS, Azure, GCP) changes outside of Terraform, so it no longer matches whatâ€™s in your Terraform state file.

Examples:

Someone manually changes an EC2 instance type in the AWS Console.

A resource is deleted outside of Terraform.

A setting is modified via an API or CLI.

ğŸ§° How to Handle Drift Detection in Terraform
âœ… 1. Run terraform plan regularly
terraform plan


Terraform compares the actual infrastructure with the Terraform state.

If it detects any drift, it shows what would change on terraform apply.

Pros:

Simple and built-in.

Works well for teams doing IaC properly.

Cons:

Doesnâ€™t track why drift happened.

Doesnâ€™t notify you unless you run it manually or via CI/CD.

âœ… 2. Use terraform apply with no changes
terraform apply


Shows and optionally fixes drift.

Can be run in automation (e.g., nightly job) to auto-heal drift.

âœ… 3. Enable Drift Detection in Terraform Cloud or Terraform Enterprise

If you're using Terraform Cloud or Enterprise, it has automatic drift detection built-in.

It monitors for changes outside of Terraform.

Alerts you when drift is detected.

Allows you to reconcile via a run.

Terraform Cloud UI:

Navigate to the workspace â†’ Drift Detection tab.

You can even configure notifications (Slack, email, etc.).

âœ… 4. Manually Reconcile Drift

If terraform plan detects drift:

You can choose to apply and bring it back to the declared config.

Or, if the external change is correct, update your Terraform code to reflect it.

âœ… 5. Use terraform state commands for inspection

If a resource was deleted manually, you might need to remove it from the state:

terraform state list
terraform state show <resource>
terraform state rm <resource>


Then re-import it or re-create it properly via Terraform.

âœ… 6. Implement Guardrails and IAM Permissions

Prevent drift in the first place by:

Limiting who can make manual changes.

Using policy-as-code (e.g., with Sentinel or OPA).

Setting up alerting on changes via cloud provider tools (e.g., AWS CloudTrail).

ğŸš¨ What Terraform Canâ€™t Detect

Terraform does not track or detect drift automatically unless:

You run terraform plan or apply, or

You use Terraform Cloud with drift detection enabled.

Drift in data sources is not considered "drift" because theyâ€™re read-only.

ğŸ§ª Bonus: CI/CD-Based Drift Detection

Set up a nightly or scheduled job to run:

terraform init
terraform plan -detailed-exitcode


Exit code 0: No changes

Exit code 2: Drift detected (plan has changes)

Exit code 1: Error

This allows you to alert or log drift automatically.

âœ… Summary
Method	Drift Detection?	Auto-Fix?	Notes
terraform plan	âœ… Yes	âŒ No	Manual; best used regularly
terraform apply	âœ… Yes	âœ… Yes	Applies the fixes
Terraform Cloud	âœ… Yes (Auto)	âŒ No	Detects and alerts, but doesn't apply
Scheduled CI/CD Plan	âœ… Yes	âŒ No	Great for automation
IAM / Cloud Auditing	âŒ Preventative	âŒ No	Helps prevent but doesnâ€™t detect

** terraform refresh vs terraform plan **
Great question! While terraform refresh and terraform plan may seem similar because both involve checking the real state of infrastructure, they serve different purposes in Terraform workflows.

ğŸ†š terraform refresh vs terraform plan
Feature	terraform refresh	terraform plan
Purpose	Updates the Terraform state file with the real infrastructure state	Shows what Terraform will do to reconcile desired and actual state
Modifies State?	âœ… Yes â€“ updates the local state	âŒ No â€“ only reads the state and shows changes
Makes Changes to Infra?	âŒ No	âŒ No (but can suggest changes)
Output	Silent update to state (no plan output)	Shows a plan of actions: add, change, destroy
Used When?	You suspect drift and want to update state manually	You want to preview changes before applying
Preferred?	Rarely used directly in newer workflows	âœ… Used daily before terraform apply
ğŸ”„ terraform refresh
ğŸ“Œ What it does:

Queries all remote resources defined in your Terraform state.

Updates the local state file to match the real infrastructure.

Does not change your .tf code or infrastructure.

ğŸ§ª Use case:

You manually changed something in the cloud and want the state file to reflect it without changing your code.

Useful in debugging or scripting, but rarely needed in standard workflows.

ğŸ“¦ Example:
terraform refresh


ğŸ“ After running it, you can run terraform show to see the updated state.

ğŸ“‹ terraform plan
ğŸ“Œ What it does:

Compares:

Your Terraform config (.tf files),

The current Terraform state file, and

The actual infrastructure.

Shows what actions (if any) would be taken by terraform apply.

ğŸ§ª Use case:

Before applying any changes, always run terraform plan to preview what will happen.

ğŸ“¦ Example:
terraform plan


ğŸ“ Output might look like:

~ resource "aws_instance" "example" {
    instance_type = "t2.micro" -> "t3.micro"
}


This shows Terraform will change the instance type.

ğŸ” Typical Workflow (Modern Terraform)
terraform init      # Initialize
terraform plan      # Preview changes
terraform apply     # Apply changes


âš ï¸ terraform refresh is implicitly run as part of terraform plan and terraform apply in Terraform v0.15+ â€” so you usually don't need to run it separately.

âœ… Summary Table
Task	refresh	plan
Updates Terraform state?	âœ… Yes	âŒ No
Makes changes to cloud?	âŒ No	âŒ No
Shows what will change?	âŒ No	âœ… Yes
Typically run manually?	âŒ Rarely	âœ… Yes (always)
Run automatically in plan/apply?	âœ… Yes (as of v0.15+)	âœ… Yes
ğŸ” When should I use refresh?

Only when:

You want to update the state manually.

You're troubleshooting.

You use terraform state commands in automation or scripts.

Otherwise, stick with plan for your day-to-day workflow.

** how do you safely rollback infrastructure changes after a failed deployment ? **

Rolling back infrastructure after a failed deployment in Terraform is not as straightforward as with some application deployment tools, because Terraform doesnâ€™t support automatic rollback out of the box. However, there are safe and practical strategies to manage or simulate rollback behavior.

ğŸš¨ Why Rollback is Tricky in Terraform

Terraform is declarative â€” you describe the desired state.

It doesnâ€™t keep a "previous good state" to automatically revert to.

If a change fails mid-deployment, some resources may have changed, and some may not â€” leading to partial updates or drift.

âœ… Strategies to Safely Roll Back Infrastructure Changes
âœ… 1. Use terraform plan + apply carefully

The first defense against needing a rollback is preventing bad deployments:

Always run:

terraform plan


to preview changes before applying.

Use manual terraform apply, or gated CI/CD pipelines with approvals.

âœ… 2. Version your Terraform code (Git)

If a deployment fails or breaks something:

You can revert the code to a previous known-good Git commit.

Then re-apply it to roll back the desired state.

git checkout <previous-good-commit>
terraform apply


Terraform will compare the current state to the old config and make changes to match the previous working version.

âœ… 3. Use Terraform Cloud/Enterprise with State History

Terraform Cloud (or Enterprise) automatically keeps historical state snapshots.

You can view and download a previous state version.

Use terraform state push to manually restore a previous state if needed (advanced and risky if misused).

âœ… 4. Manually Revert Resources

If a resource was updated incorrectly, you can:

Revert the .tf configuration manually to the previous values.

Run:

terraform apply


to bring the infrastructure back in line.

This is essentially a manual rollback â€” youâ€™re telling Terraform to return things to how they were.

âœ… 5. Use Feature Toggles / Blue-Green / Canary Deployments

For zero-downtime or safer changes, especially in production:

Use blue-green deployment strategies:

Deploy new infra alongside existing.

Shift traffic (e.g., with load balancers).

Delete old infra only after verifying success.

Use feature flags or canaries to reduce blast radius.

This avoids the need for immediate rollback and increases confidence.

âœ… 6. Create Manual State Backups Before Critical Changes

Before major changes, run:

cp terraform.tfstate terraform.tfstate.backup


If a critical failure happens and you know what you're doing, you can use:

terraform state push terraform.tfstate.backup


âš ï¸ Only do this with extreme caution. You're forcibly overwriting the state.

âŒ What Not to Do
Action	Why Itâ€™s Risky
Deleting resources manually	Causes drift â€” Terraform wonâ€™t track it
Editing state manually (JSON)	Can corrupt your state file
Applying code without planning	Might break more things
ğŸ§¾ Summary
Strategy	Safe Rollback?	When to Use
Revert code in Git + apply	âœ… Yes	Most common and safe
Use Terraform Cloud state history	âœ… Yes	With Terraform Cloud or Enterprise
Manually revert .tf configuration	âœ… Yes	When you know what needs reverting
Restore old state file (state push)	âš ï¸ Risky	Only for experts in critical cases
Blue-green / canary deployments	âœ… Yes	For production & critical systems
ğŸ’¡ Pro Tip

Always test changes in lower environments before deploying to production, and use CI/CD pipelines with plan approval gates to minimize risk.
