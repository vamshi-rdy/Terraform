Commands to Manage Workspaces
ğŸ”¹ 1. Create a New Workspace
terraform workspace new <workspace_name>


Example:

terraform workspace new dev

ğŸ”¹ 2. List All Workspaces
terraform workspace list


ğŸ”¹ The current workspace is marked with an asterisk (*).

ğŸ”¹ 3. Switch to an Existing Workspace
terraform workspace select <workspace_name>


Example:

terraform workspace select dev

ğŸ”¹ 4. Show Current Workspace
terraform workspace show

ğŸ”¹ 5. Delete a Workspace

(Only possible if the workspace is not currently selected)

terraform workspace delete <workspace_name>

âš ï¸ Notes

The default workspace is always present.

Workspaces isolate state files, not resources themselves unless your configuration (e.g., backend or resource names) accounts for the workspace name.

Best practice: Use terraform.workspace in resource naming or backend configuration to fully isolate resources across workspaces.


** 
Great! Hereâ€™s a full example of how to use terraform.workspace in your Terraform configuration to manage isolated environments like dev, stage, and prod using workspaces.

âœ… Goal

We'll create an S3 bucket with a name that changes based on the current workspace, so each workspace creates its own isolated resource.

ğŸ“ Example: main.tf
provider "aws" {
  region = "us-east-1"
}

resource "aws_s3_bucket" "example" {
  bucket = "my-app-bucket-${terraform.workspace}"
  acl    = "private"

  tags = {
    Environment = terraform.workspace
  }
}

output "bucket_name" {
  value = aws_s3_bucket.example.bucket
}


Steps to Use It
1. Initialize Terraform
terraform init

2. Create and Switch to a Workspace
terraform workspace new dev


(or switch to an existing one)

terraform workspace select dev

3. Apply the Configuration
terraform apply


ğŸ”¸ This will create an S3 bucket named my-app-bucket-dev.

4. Switch to Another Workspace
terraform workspace new prod
terraform apply

This creates a separate bucket like my-app-bucket-prod.

Each workspace maintains its own state, so the dev and prod buckets won't conflict or overwrite each other.

Important Notes

You must ensure that resource names (like S3 buckets) are unique across workspaces, especially for global resources (S3 bucket names must be globally unique in AWS).

Use terraform.workspace in tags, names, or logic to customize resources per environment.




***
Great â€” letâ€™s extend the setup to include workspace-specific variables and show how to configure different backends per workspace if needed.

ğŸ¯ Goal

We'll:

Use different values (e.g. tags or instance types) depending on the workspace.

Optionally configure workspace-aware backends (e.g. different S3 state files per workspace).

1ï¸âƒ£ Workspace-Specific Variables Using locals

You can use a locals block to change values based on the current workspace.

ğŸ”¸ Example with EC2 instance type:
locals {
  instance_type_map = {
    dev     = "t2.micro"
    staging = "t3.micro"
    prod    = "t3.large"
  }

  instance_type = lookup(local.instance_type_map, terraform.workspace, "t2.micro")
}

resource "aws_instance" "example" {
  ami           = "ami-0c55b159cbfafe1f0" # Use your region's latest Amazon Linux 2 AMI
  instance_type = local.instance_type

  tags = {
    Environment = terraform.workspace
  }
}


So:

dev â†’ t2.micro

prod â†’ t3.large

Defaults to t2.micro if workspace not listed.

2ï¸âƒ£ Different Terraform State Backends per Workspace (Optional Advanced)
âš ï¸ Caution

Terraform does not support dynamic backends (i.e. using terraform.workspace directly in backend blocks). But you can manually separate state per workspace by using key patterns in the backend configuration.

ğŸ”¸ Example: backend.tf
terraform {
  backend "s3" {
    bucket = "my-terraform-state-bucket"
    key    = "env/${terraform.workspace}/terraform.tfstate"
    region = "us-east-1"
  }
}

ğŸš¨ But this wonâ€™t work directly!

Because the backend block is evaluated before any variables or functions like terraform.workspace.

âœ… Workaround: Use CLI Workspaces + Pre-Set Backend Files

You can:

Create separate backend-<workspace>.tf files for each workspace.

Use them like:

terraform init -backend-config=backend-dev.tf
terraform workspace select dev

ğŸ“ backend-dev.tf
bucket = "my-terraform-state-bucket"
key    = "env/dev/terraform.tfstate"
region = "us-east-1"


Repeat for backend-prod.tf, backend-staging.tf, etc.

âœ… Summary
Feature	Terraform Support	Notes
terraform.workspace	âœ… Yes	Use in resource names, tags, locals
Dynamic backends	âŒ No	Workaround with separate backend config files per workspace
Workspace-specific variables	âœ… Yes	Use locals + maps + lookup()



** IMPORT **

Absolutely. Letâ€™s walk through a complete example: how to import a manually created AWS resource into Terraform step by step, with a real Terraform .tf file example.

âœ… Scenario Example: Import a Manually Created AWS EC2 Instance

Letâ€™s say:

You manually launched an EC2 instance via the AWS Console

Its instance ID is i-0123456789abcdef0

You now want to bring it under Terraform control

ğŸ”§ Step-by-Step: Importing AWS Resource into Terraform
ğŸŸ¢ Step 1: Create a Terraform Resource Block

First, create a minimal Terraform resource block for the EC2 instance in your Terraform configuration.

ğŸ“„ main.tf

provider "aws" {
  region = "us-east-1"
}

resource "aws_instance" "imported_ec2" {
  # No arguments yet; Terraform will not use this to change anything yet.
  # We'll fill in the actual attributes after importing.
}

ğŸŸ¢ Step 2: Initialize Terraform (if not already done)
terraform init

ğŸŸ¢ Step 3: Import the EC2 Instance into Terraform State

Use the EC2 instance's ID from the AWS Console.

terraform import aws_instance.imported_ec2 i-0123456789abcdef0


âœ… This adds the EC2 instance to your .tfstate file, so Terraform knows it exists.

ğŸŸ¢ Step 4: Review the Imported Resource

Run:

terraform state show aws_instance.imported_ec2


Youâ€™ll get output like this:

# aws_instance.imported_ec2:
resource "aws_instance" "imported_ec2" {
  ami                          = "ami-0c55b159cbfafe1f0"
  instance_type                = "t2.micro"
  subnet_id                    = "subnet-abc123"
  vpc_security_group_ids       = ["sg-0abc123"]
  associate_public_ip_address  = true
  key_name                     = "my-keypair"
  tags = {
    Name = "ManuallyCreatedEC2"
  }
}

ğŸŸ¢ Step 5: Update the .tf File with Actual Attributes

Now, modify your main.tf resource to match the real configuration of the instance:

resource "aws_instance" "imported_ec2" {
  ami                    = "ami-0c55b159cbfafe1f0"
  instance_type          = "t2.micro"
  subnet_id              = "subnet-abc123"
  vpc_security_group_ids = ["sg-0abc123"]
  associate_public_ip_address = true
  key_name               = "my-keypair"

  tags = {
    Name = "ManuallyCreatedEC2"
  }
}

ğŸŸ¢ Step 6: Run terraform plan to Confirm No Drift
terraform plan


If your .tf file matches the state and real AWS resource, the plan will show:

No changes. Your infrastructure matches the configuration.

âœ… Success â€” the resource is now under Terraform management!

âœ… Summary Table
Step	Command / Action	Purpose
1	Create resource block in .tf	Define structure for imported resource
2	terraform init	Initialize Terraform
3	terraform import <resource> <id>	Import AWS resource into state
4	terraform state show <resource>	View imported attributes
5	Update .tf file	Match actual resource configuration
6	terraform plan	Confirm sync between code and AWS
ğŸ” Bonus: Import Other AWS Resources
AWS Resource	Terraform Type	Example Command
S3 Bucket	aws_s3_bucket	terraform import aws_s3_bucket.mybucket my-console-bucket
IAM Role	aws_iam_role	terraform import aws_iam_role.myrole my-iam-role-name
Security Group	aws_security_group	terraform import aws_security_group.sg sg-0123abcd
